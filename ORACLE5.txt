1.视图的定义语法
2.视图的使用限制
在所有进行的sql语句之中,查询是最复杂的,而且查询还和具体的开发有关,那么在开发过程中
程序员完成的并不是数据库的所有内容.而更多的是应该考虑到程序的设计结构。可是没有一个
项目里面不会包含有复杂查询,那么程序员如何从复杂查询中解脱出来呢?
    所以在这种情况下提出了视图的概念。利视图可以实现复杂sql语句的封装操作。从实际开发
来讲,一个优秀的数据库设计人员,除了要给出合理的数据表结构之外,还应该将所有可能使用到
的查询封装好视图,一并交给开发者。
   视图依然属于DDL的定义范畴
CREATE [OR REPLACE] VIEW 视图名称 AS 子查询;
范例:创建视图
CREATE VIEW myview AS SELECT * FROM emp WHERE deptno=10;
希望将10部门的所有雇员信息保存在视图当中。在ORACLE10g及以前的版本, scott是可直接进行视图创建的,
但是从Oracle10G R2版本开始如果要想创建视图,那么就需要单独分配创建视图的权限。
范例:为scott分配创建视图的权限。
CONN sys/change_on_install AS SYSDBA;
GRANT CREATE VIEW TO scott;
CONN scott/tiger;  
	权限分配完成之后则可以进行视图的创建操作。视图本身属于数据库对象,所以要想
查看视图的信息可以使用user_views字典完成。在这个数据字典里可以查询到视图的具体语法。
SELECT * FROM user_views;
  视图可以像普通的数据表那样直接查询
SELECT * FROM myview;  
发现查询视图与之前直接使用SELECT查询的结果是完全一样的,所以视图就包装了sql语句,而开发者可以通过视图
简单的查询到所需要的数据。
   于是下面可以继续利视图包装一个复杂查询  
CREATE  OR REPLACE VIEW myview AS   
SELECT d.deptno,d.dname,d.loc,temp.count FROM dept d,(
	SELECT deptno dno,COUNT(*) count
	FROM emp
	GROUP BY deptno
)  temp
WHERE d.deptno=temp.dno(+); 
由于myview视图的名称已经被占用了,所以理论上应该先删除,而后再创建新的视图,可是
删除和创建之间可能产生间隔。所以在实际之中,由于视图频率开发较高,而且与开发有关系,那么一般情况下不会选择
删除后再重新创建,而是选择进行视图的替换。利新的查询替换掉旧的查询(OR REPLACE)。
从实际的开发分工来讲,此部分的操作应该是由数据库开发人员进行的,但是从现实来讲,这基本上除了大的开发团队之外,
大部分的中小开发团队都会由开发人员自己编写。

实际上视图只是包含有查询语句的临时数据,并不是真实存在的,可是在默认的情况下,视图是可以进行修改操作的。
CREATE OR REPLACE VIEW myview AS SELECT * FROM emp WHERE deptno=20;
  此时创建的myview视图之中,deptno=20是视图数据存在依据,默认情况下,是可以修改的。
范例:更新视图中数据的部门编号(视图的存在条件)
UPDATE  myview SET deptno =30 WHERE empno=7369;
发现此时更新了视图,结果导致emp数据表中的内容也发生了变化。所以为了保证视图的创建条件不能够被更新,
则可以在创建视图的时候使用 WITH CHECK OPTION子句。
CREATE OR REPLACE VIEW myview AS SELECT * FROM emp WHERE deptno=20 WITH CHECK OPTION;
此时使用了 WITH CHECK OPTION 可以保证视图的创建条件不能被更新。
ORA-01402: 视图 WITH CHECK OPTION where 子句违规
  但是视图中不光只存在有创建条件的字段,还可能包含有其他字段。可是在现在的操作中,可以修改视图中的其他字段内容。
范例:修改其他字段
UPDATE  myview SET sal =80000 WHERE empno=7369;  
此时更新的操作成功了。发现视图更新时改变的是数据表中的数据,那么这样的做法同样也不合理。
所以一般创建视图的时候,由于里面都属于映射的数据,那么本质上不建议进行修改,最好的视图就是创建一个只读视图。
使用WITH READ ONLY 子句完成。
CREATE OR REPLACE VIEW myview AS SELECT * FROM emp WHERE deptno=20 WITH READ ONLY;
此时再次发出修改操作
ORA-42399: 无法对只读视图执行 DML 操作
这样就避免了通过视图的临时数据修改真实数据的影响。
疑问?我觉得直接改视图挺方便,为什么你非说要使用只读视图呢?
分析问题,如果只是单表查询,没有必要使用视图。视图是封装复杂查询。
CREATE OR REPLACE VIEW myview AS SELECT e.empno, e.ename,e.job,d.dname,e.sal,m.ename mname FROM
emp e,dept d,emp m WHERE e.deptno=d.deptno AND e.mgr=m.empno(+);
此时的复杂查询封装为视图才觉得是有意义的。那么此时没有增加WITH READ ONLY等操作。
UPDATE myview SET sal =8000,dname='SALES',mname='KING' WHERE empno=7902;
此时没有增加限制条件,但出现了如下限制信息。
ORA-01776: 无法通过联接视图修改多个基表
如果这种情况真的要改,那么可以使用替代触发器完成。
总结
   理论上从正规的开发项目来讲,一个数据库之中应该包含多个视图,但是现实开发团队有些不使用视图,
那就好好学习复杂查询。

了解同义词的作用即可
之前使用过这样一种查询
SELECT SYSDATE FROM dual;
之前说过:dual是一张临时表,但是这个表是属于谁的呢?
通过一系列的查询可以发现,dual数据表本身属于sys用户的,那么有人就出现一个疑问了,
既然dual属于sys,那么按照之前的概念来讲,不同的用户要进行表的互相访问,那么前面需要使用模式名。
如果说scott用户要使用dual,则应该使用sys.dual才对。而这个操作就属于同义词的定义范畴,也就是说dual是sys.dual的同义词。
如果要想创建同义词,则可以使用如下的语法完成。
CREATE [PUBLIC] SYNONYM 同义词名称 FOR 模式名称
范例:将scott.emp数据表映射为semp
CREATE SYNONYM semp FOR scott.emp;
同义词创建完成后,可以直接用同义词进行数据查询。
此同义词只能被sys用户使用,其他用户无法使用
如果要想让一个同义词被所有用户使用,应该创建为公共同义词
范例:重新创建同义词
CONN sys/change_on_install AS SYSDBA;
DROP SYNONYM semp;
CREATE PUBLIC SYNONYM semp FOR scott.emp;
	同义词属于oracle自己的概念,对于实际开发帮助不大。理解dual的使用即可。
	
分析索引的主要作用以及索引的定义和使用。
先抛开索引的概念不看。只看索引能够做什么事情,以及为需要有索引。
现在来观察如下的一段程序代码。
SELECT * FROM emp WHERE sal>1500;
于是现在就通过此语句来分析数据库在这之中做了什么,为了大家观察方便,下面打开追踪器。
切换到sys用户。
CONN sys/change_on_install AS SYSDBA;
SET AUTOTRACE ON;
打开之后直接在sys用户中进行性能信息的查询,此时的查询会返回结果之外,还会返回给用户一些分析的信息。
TABLE ACCESS FULL
此时直接描述的是要进行全表扫描,就属于逐行扫描。而且最为关键的问题在于,如果说现在emp表的数据有50w条,可能在
第20920条后就没有任何的雇员记录可以满足此条件,那么这个时候以上的语句会继续向后查,很明显这就是一种浪费。
所以这个时候的性能一定不可能变快。
   那么已经知道了问题,那么该如何解决这样的查询呢?那么现在第一个想法就是需要知道明确的数据排序。如果直接使用ORDER BY,
   但是ORDER BY子句是整个查询语句中最后执行的,也就是说此时还没到ORDER BY中。
所以在这种情况下,数据的最好排列是根据树排列。
    树的排列原则:选取一个数据作为根节点,比此节点大的数据放在右子树,比节点小的数据放在左子树,这样就可以实现排序。
但是现在的问题是,选什么数据来操作呢?本程序使用的是sal字段,所以就应该利sal来操作索引。	
要想设定索引,必须设置一个指定的字段。
范例:为scott.emp表在sal字段上创建索引。
CREATE INDEX emp_sal_ind ON scott.emp(sal);
一旦索引创建完成之后,下面重新发出一次查询的指令。
通过查询分析器此时的查询不再使用全表扫描。
TABLE ACCESS BY INDEX ROWID
INDEX RANGE SCAN
  此时进行查询的时候不是全部数据都查询了,而是查询了所需要的范围的内容。
虽然利索引可以进行查询提升,但是需要明确一个问题所在,索引提升查询的关键在于:那颗索引树。那么如果
说你的数据表之中,sal字段的内容都在重复改变的时候,那么这颗树将杀死你。
  树的维护操作是需要花费时间的,如果数据小可以在很短的时间内进行树的生成,但是如果数据量一大,时间会花费巨大。
(所以如果说现在不想重复的进行树的维护,那么就必须保证数据的不可更改与唯一性,所以默认情况下会在主键约束上自动追加一个索引)。
  在现实开发中又会出现一个问题:
     -保证用户的回应速度快,没有延迟:
     -能够承受用户大量的更新操作。
  如果要想查询速度快,必须使用索引:
  如果要想保证更新速度,那么不能使用索引。
  所以这个时候最好的做法是牺牲实时性。等于有两数据库,一个数据库专门给用户负责查询使用,
另外一个数据库专门给用户更新操作使用。对于查询的数据库可以在每天凌晨2-3点的时候进行信息的
统一保存或者是统一的分析后保存。

用户的维护以及权限的划分。
如果以后在学习中使用Oracle,使用的就是scott/tiger。所有的关注点是在于程序的逻辑结构上,数据库对于开发人员而言
主要的目的就是进行数据的交互。
    之所以要讲解用户管理部分,主要是为了解释DCL的sql分类。DCL属于数据控制语言,主要有两语法
REVOKE(回收),GRANT(授权)。这样的两命令必须以用户对象为基础使用。
    下面以狗狗的从业经历为例,说一下用户从无到有,再分配权限,再到堕落以及删除的过程。
如果要想进行用户的创建,那么必须有管理员的权限,本次就直接使用sys用户。使用sys登录。
1.sys登录
CONN sys/change_on_install AS SYSDBA;
2.创建一个新的用户,名字为dog,密码为wangwang
CREATE USER dog IDENTIFIED BY wangwang;
  那么现在用户已经创建完成了,所以能不能使用此用户登录呢?
ORA-01045: user DOG lacks CREATE SESSION privilege; logon denied
  每一个新的用户本身不具备任何的权限,而在Oracle数据库里面,如果用户要想登录,则必须具有创建session的权限。
如果要分配权限则可以使用如下的语法;
GRANT 权限 1,权限 2,...TO用户名:
范例:将创建session的权限赋予dog
GRANT CREATE SESSION TO dog;
既然已经使用了dog用户登录成功,那么下面创建序列和表?
CREATE SEQUENCE myseq;
CREATE TABLE mytab(
	name VARCHAR2(20)
);
权限不足。
实际上进来后依然需要权限,一步一个脚印,需要创建序列的权限,需要创建表的权限,还有可能需要一堆其他的权限。
这样做太麻烦了,所以在Oracle里面提供有一种角色的概念,所谓的角色指的是包含有若干个权限,Oracle里面主要使用
两角色:CONNECT(了解)、RESOURCE(表以及表空间)。
范例:将两个角色授予dog用户。
GRANT CONNECT,RESOURCE TO dog;
用户得到了新的权限之后,必须重新登录后才可以取得新的权限。
一旦有了用户的问题,那么就会出现用户管理问题。
范例:修改用户密码,由于用户并不多,所以这种用户的维护就可以由sys进行了。
ALTER USER dog IDENTIFIED BY miaomiao;
管理员修改密码之后,肯定需要用户自己重新设置一个新的密码。
范例:让用户密码过期。
ALTER USER dog PASSWORD EXPIRE;
到此dog用户的辉煌就结束了,下面开启下篇:堕落篇。
范例:锁定用户
ALTER USER dog ACCOUNT LOCK;
范例:用户解锁
ALTER USER dog ACCOUNT UNLOCK;
   除了以上给出的一些系统权限之外,还可以使用一些对象权限。
   可以针对于一个对象下的数据表进行访问的定义;有四种权限:INSERT ,UPDATE,DELETE,SELECT
范例:下面将scott.emp表的SELECT,INSERT权限授予 dog用户。
GRANT SELECT,INSERT ON scott.emp TO dog;
   后面发现dog用户不需要这么多的权限,所以开始了权限的回收。
范例:回收scott权限
REVOKE SELECT,INSERT ON scott.emp FROM dog;    
范例:回收其它所授予的权限
REVOKE CONNECT,RESOURCE,CREATE SESSION FROM dog;
既然用户已经没有存在的意义了,那么可以进行删除操作。
ORA-01922: 必须指定 CASCADE 以删除 'DOG'
DROP USER dog CASCADE;
  别考虑删除用户的情况。
总结
   主要是为了讲解权限的sql操作支持。

1.数据的导入与导出
2.数据库的冷备份。
 数据库的备份操作在所有项目运营环境中都需要涉及到。
数据的导出与导入
  这种的备份方式主要是进行数据表中数据导入与导出的操作,针对于一个用户完成的。
1.数据的导出
  -首先需要准备一个进行数据备份的目录,假如说现在将D:\backup目录作为备份路径。  
  -需要进入到backup目录中(以命令行的方式进行操作)
  -输入exp指令,导出数据
2,数据的导入。
  -进入到备份文件所在路径:
  -输入imp指令:
  在实际的备份操作之中这样的操作使不了,因为在其导出过程之中,必须保证其他用户不能更新数据。

数据库的冷备份
    数据库的冷备份严格来讲称为归档备份,指的是数据库要关闭服务,所有的事务都需要提交了。从实际来讲
	如果要进行备份则需要备份如下的内容:
	    -控制文件:控制着整个Oracle的实例信息,可以使用v$controlfile数据字典找到。
		-重做日志文件:通过v$logfile数据字典找到;
		-数据文件:通过v$datafile数据字典找到;
		-核心配置文件(pfile):使用SHOWPARAMETER pfile找到。
		数据库的备份操作肯定要由管理员进行。
		1.使用sys登录
		CONN sys/change_on_install AS SYSDBA;
		2.查找控制文件信息
		SELECT * FROM v$controlfile;
		3.查找重做日志文件信息
		SELECT * FROM v$logfile;
		4.找到所有数据文件信息
		SELECT * FROM v$datafile;
		5,找到pfile文件(W:\app\22677\product\11.2.0\dbhome_1\database\SPFILEMLDN.ORA)
		show parameter pfile;
		6.记录好这些文件的路径
		7.关闭Oracle服务。
		SHUTDOWN IMMEDIATE
		8.拷贝出所有的备份文件;
		9.重新启动服务;
		STARTUP
		  这种备份是允许关闭计算机的备份
备份的操作属于管理员的任务,我们不需要涉及到。

   数据库设计的三个参考范式。
   现在所给出的三个参考范式只能够说是一种思路,但是实际之中不可能完全按照设计范式的要求做。
第一范式(单表)
数据表中每一个列的内容不可再分。现在假设定义一个用户信息表,包含如下字段:
CREATE TABLE 用户(
	编号    NUMBER,
	姓名    VARCHAR2(20),
	联方式  VARCHAR2(200)
);   
   联方式会有很多,可能包含:地址,电话,email,qq,固定电话,所以此时联方式列的内容依然
可以再分,这样的设计就不符合于第一设计范式。合理的做法应该是
CREATE TABLE 用户(
	编号    NUMBER,
	姓名    VARCHAR2(20),
	地址    VARCHAR2(200),
	邮编    VARCHAR2(8),
	联系电话  VARCHAR2(200)
); 
实际上第一范式的核心意义就在于使用常用的数据类型:NUMBER,DATE,VARCHAR2,CLOB。
可以回顾一下salgrade表。
  这里面有两个注意点:
    -对于日期描述坚决不能够拆分为:年、月、天;
   -对于姓名字段与国外是不同的,国外分别为firstlast_name,last_name。

第二设计范式(多对多)
数据表中不存在非关键字段对任意一候选关键字段的部分函数依赖   
对于此概念有两层次的解释:
   -先通过函数关系来进行描述,现在假设设计一张订单表
CREATE TABLE 订单(
	商品单价   NUMBER,
    购买数量   NUMBER,
    总价       NUMBER	
);   
此时存在有函数关系,总价=商品单价*购买数量。
   -函数依赖指的是某几个字段的集合是否可以推到出其他列的内容
 
 电影名称  年份   导演       演员      出版商
 美人鱼     2016  周星驰     邓超,xx   光线传媒
 非诚勿扰   2004  冯小刚     葛优,舒淇 华谊兄弟
 甲方乙方   1998  冯小刚     葛优,刘培 华谊兄弟
 大话西游   1998  周星驰     吴孟达    光线传媒
 
现在这是一张表,所以在这个过车之中就会出现如下的关系:
(电影名称,年份,出版商) = 导演;
(年份,电影名称)≠演员
如果要想更好的理解第二范式,那么最好是通过一个实际的案例来说明,例:现在定义一个学生选课的系统,
每个学生针对于课程可以有一个成绩,于是此时按照第一范式设计
CREATE TABLE 学生选课(
	学生编号  MID PRIMARY KEY,
	学生姓名  VARCHAR2(20),
	学生年龄  NUMBER,
	课程名称  VARCHAR2(50)
	课程学分  NUMBER,
	考试成绩  NUMBER
);
此时的确是符号于第一设计范式。但是此时就会存在有问题了。
INSERT INTO(学生编号,学生姓名,学生年龄,课程名称,课程学分,考试成绩)
VALUES(1.'张三',20,'java',2,89);
INSERT INTO(学生编号,学生姓名,学生年龄,课程名称,课程学分,考试成绩)
VALUES(2.'李四',20,'Oracle',1,99);
INSERT INTO(学生编号,学生姓名,学生年龄,课程名称,课程学分,考试成绩)
VALUES(1.'张三',20,'ORACLE',1,95);
此时的设计包含如下的问题:
  -主键信息重复或者说无法确定主键;
  -学生,课程信息重复(有可能会更新很多的数据);
  -如果某一门课程没人选择参加了,那么课程就没了。
所以此时利第一范式根本就没办法解决当前的设计问题。此时的关系是一个学生可以选择多门课程,
一门课程也可以由多个学生参加,每个学生针对每门课程可以有一个成绩。当时使用的是多对多关系解决的。
范例:修改设计
CREATE TABLE 学生(
	学生编号  MID PRIMARY KEY,
	学生姓名  VARCHAR2(20),
	学生年龄  NUMBER
);
CREATE TABLE 课程(
	课程编号 CID PRIMARY KEY,
	课程名称  VARCHAR2(50),
	课程学分  NUMBER
);
CREATE TABLE 学生_课程(
	学生编号 MID REFERENCES..,
	课程编号 CID REFERENCES..,
	课程成绩 NUMBER
);
 多对多的查询需要三张数据表一起完成,所以查询复杂。
 
第三设计范式(一对多)
数据表之中不存在非关键字段对任意一候选关键字段传递函数依赖
首先来解决传递函数是什么意思? 现在建立一张雇员表
雇员编号       姓名     部门     位置     工资
  1            张三     测试部   上海     1000
  
此时里面有一个传递依赖:利用编号与姓名可以确定一个雇员的部门名称,但是通过部门名称又可以找到部门位置,
这个称为传递函数依赖。
     现在一个学校有多个学生。如果现在使用第一设计范式。如果使用第一范式学校信息重复。如果使用
	 第二设计范式,可以描述出一个学校有多个学生,但是又会描述出一个学生属于多个学校,那么此时就可以使用第三设计范式。
CREATE TABLE 学校(
	学校编号  NUMBER PRIMARY KEY,
	名称      VARCHAR2(50)
);
CREATE TABLE 学生(
	学生编号 MID PARIMARY KEY,
	学生姓名  VARCHAR2(20),
	学生年龄  NUMBER,
	学校编号  NUMBER REFERENCES ...
);	 
  这就是之前一直在讲解的dept-emp关系。
总结
  三个设计范式只是一个设计初的思考方式。但是在实际运行中,这三个范式必须要打破。  
	 

如何使用powerDesigner设计工具
利用powerDesigner还原dept-emp表
powerDesigner设计工具主要是进行数据表的设计的。这个工具是由Sybase公司出品的。
在进行数据库设计的过程中,往往都会借助一些开发工具。
如果要使用PowerDesigner设计工具进行设计,那么需要首先建立一个物理数据模型
建立的数据模型必须选择ORACLE
name表示的是在工具里面的名字,而code是表示生成代码的名字。
设置关联关系子表连向父表
项目开发之中,此类的知识一定要重点掌握。

任何的系统起码具备两个用户级别:前台普通用户,后台管理员。后台管理员负责发布所有的信息,而前台用户只是
根据已发布的内容使用。
1.本系统主要针对于企业内部员工使用,考虑到系统的安全性,所有的用户信息必须通过系统管理员
进行录入,所有员工凭借自己的员工编号以及密码进行系统登录;
 本系统主要针对于企业内部员工使用,既然是内部员工使用,那么用户的注册功能肯定不需要创建。
用户信息和管理员肯定是两张表,而且用户信息由管理员添加,那么为了得到数据的准确性,需要知道用户
是由哪个具体的管理员负责添加。这个时候相当于一个管理员负责多个用户,那么就属于一对多的关系,一对
多属于第三设计范式。   
   对于此时的用户信息表之中需要注意的问题是,只关心核心字段,其他的非核心字段再进一步设计的时候再完善。
   以上是一个正常的开发思路,但是现在的开发思路变了,管理员也应该是一个用户。所以现在的开发会将管理员
   和用户信息保存在一起。但是为了区分到底保存的是管理员还是用户,那么可以设置一个标记字段
      -字段名称为flag, flag =0 为普通用户 ,flag =1 管理员 ,flag = 2超级管理员。
	 但是此时要想清楚的记录下每个管理员创下的用户信息
     于是可以参考emp表的设计,在用户表里面增加一个管理员的信息。
如果你数据表针对这样设计了,在日后使用Hibernate做数据库的开发的时候就会出现可怕问题。
但是使用MyBatis就没事。那么如果现在要想更好的去改变这样设计,希望所有的表都可以使用它。
还可以中间增加一张表做数据保存

2.员工登录到系统之后可以进行所有培训课程的查看,或者根据课程分类(课程分类为两级,即:一级分类下会存
在有多个二级分类)进行课程查找;	 
   此时一个级课程分类下会包含有若干个二级课程,这个属于一对多关系
但是在每个分类下会存在若干门课程,课程属于一级分类,也会属于二级分类。那么这个时候对于课程中需要的
信息:编号(自动增长),名称,老师(可能是用户,所以需要做一个标记,tflag=0不是老师,tflag=1是老师),课时、
图片、内容简介、课时、开始时间、结束时间。
但是这个时候新的问题出现了。一个课程下会存在有若干个内容。如果要是课程分章,那么还需要引入课程章节表。
3. 一个课程包含多个章节,一个章节包含有多个内容。
  还可能存在课程状态。因为课程需要审核。还需要由管理员发布(用户),所以还需要设置一个发布用户的外键。
  4.如果员工要想进行课程的学习,则必须选择"参加该课程",参加之后才可以播放课程,同时要求记录好改雇员的课
程学习进度;
    -一个员工可以参加多门课程,一门课程可以有多个参加的员工,使用第二范式
    -追踪员工的课程学习进度。
        -假设一门课程有30节课,那么在该员工选择完参加该课程之后,应该有一个记录表,自动生成该员工的所有与
本课程有关的内容,但是此内容后面的学习标记设置为默认值,对于学习状态有以下几种取值
        -flag=0 :未开始学习
        -flag=1 :已开始学习,但是没有学习完;
        -flag=2 :已学习完成。
5.员工可以针对于参加的课程进行测试,而在测试时以选择题为主,进行四选一的回答,并且要求可以根据已有
题库随机生成测试题。
     一门课程会有一套试题库。一对多关系,第三设计范式。但是题库里面包含若干个题目,四选一最简单。
	 现在如果员工选择开始测试,则应该有一张测试记录表(假设该员工只能够测试一次),那么在这张表里面需要生成
	 所有动态抽取出来的题目,而抽取的个数由题库提供的。
	 6.每个员工可以针对于每节课程进行自己的笔记记录。
	 笔记信息就是一个员工对于某个课程的记录,如果再细致一些,可以针对于某节课程的记录。
	 7.员工登录系统之后可以进行系统公告的浏览,同时可以自动提示用户有多少属于未读公告信息
	 公告是由管理员发出的,所以一个管理员可以发出多个公告信息
	 每一个用户需要针对于读过的公告做一个标记。
	 8.管理员可以进行针对于课程分类,课程内容,测试题进行管理;
	 管理员本身就是用户,也就是说一个用户可以发布多个课程,一个用户可以发布多个测试题。
	 9.管理员可以控制课程的发布管理;
	 课程表里面有一个发布状态字段。0表示未发布,1表示发布,2表示代审核
	 10.系统中允许有一位超级管理员,同时超级管理员不能够删除。不同的管理员可以根据其所对应的角色不同,生成
	 不同的管理菜单。
	    超级管理员已经由级别描述了,这一点可以省略了,但是下面才是核心的设计问题。
		每一个管理员所具备的功能称为权限组(GROUP),但是每一个权限还需要划分为具体的子权限(Privilege)。
   总结  
数据库设计没有标准答案,也几乎不会存在完全符合于范式的设计。而现在的设计也没有考虑到过多的性能。  	
	 
	 
	 
	 
	 
	 
   
   




  
	
	
 